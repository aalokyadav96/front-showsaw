// mapModule.js

import { createElement } from "../../components/createElement.js";
import { SRC_URL, apiFetch } from "../../api/api.js";
import displayPlace from "../place/displayPlace.js";

/**
 * Loads map configuration and marker data from the backend,
 * then displays the map.
 *
 * @param {HTMLElement} contentContainer - The container to render the map UI.
 * @param {boolean} isLoggedIn - Whether the user is logged in.
 * @param {Object} entityx - Entity information containing `id` and `type`.
 */
export async function loadMap(contentContainer, isLoggedIn, entityx) {
  try {
    // Fetch dynamic config and markers from backend.
    const config = await apiFetch(
      `/maps/config/${entityx.type}?id=${encodeURIComponent(entityx.id)}`
    );
    const markers = await apiFetch(
      `/maps/markers/${entityx.type}?id=${encodeURIComponent(entityx.id)}`
    );
    // Adjust map image for events.
    if (entityx.type === "event") {
      config.mapImage = `${SRC_URL}/eventpic/seating/${entityx.id}seating.jpg`;
    }
    displayMap(contentContainer, isLoggedIn, config, markers);
  } catch (err) {
    console.error("Failed to load map:", err);
  }
}

/**
 * Primary function that builds and displays the map along with UI controls.
 *
 * @param {HTMLElement} contentContainer - The container for rendering the map.
 * @param {boolean} isLoggedIn - Indicates if the user is logged in.
 * @param {Object} config - Map configuration with keys:
 *   - mapImage: URL for the map image.
 *   - spritePositions: Object mapping marker types to sprite positions.
 *   - typeLabels: Object mapping marker types to labels.
 * @param {Array} markers - Array of marker data from the backend.
 */
export function displayMap(contentContainer, isLoggedIn, config, markers) {
  // Clear any previous content.
  contentContainer.innerHTML = "";

  // Build the UI modules.
  const mapContainer = createMapContainer(config.mapImage);
  const legend = createLegend(config.typeLabels);
  const zoomControls = createZoomControls();
  const minimap = createMinimap(config.mapImage);
  const infoPanel = createInfoPanel();

  // Append UI modules to the container.
  contentContainer.append(mapContainer, legend, zoomControls, minimap, infoPanel);

  // Create and add markers to the marker layer.
  const markerElements = createMarkers(markers, config.spritePositions);
  const markerLayer = mapContainer.querySelector("#marker-layer");
  markerElements.forEach((el) => markerLayer.appendChild(el));

  // Set up interactions for panning, zooming, minimap recentering, legend filtering, etc.
  const mapInteractions = initMapInteractions(mapContainer, zoomControls, minimap);
  attachLegendInteractions(legend, markerElements);
  attachMarkerClickListeners(markerElements, isLoggedIn, infoPanel);

  // Perform an initial render (update zoom and minimap viewport).
  mapInteractions.applyZoom();
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   UI COMPONENTS & HELPERS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/**
 * Creates the main map container with the map image and marker layer.
 *
 * @param {string} mapImageUrl - URL of the map image.
 * @returns {HTMLElement} - The map container element.
 */
function createMapContainer(mapImageUrl) {
  // Map image element.
  const mapInner = createElement("img", { id: "map-inner", src: mapImageUrl });
  // Marker layer, positioned absolutely over the map.
  const markerLayer = createElement("div", {
    id: "marker-layer",
    style: "position:absolute;top:0;left:0;width:100%;height:100%",
  });
  // Wrapper contains map image and marker layer.
  const mapWrapper = createElement("div", { id: "map-wrapper" }, [
    mapInner,
    markerLayer,
  ]);
  // Container for the whole map.
  return createElement("div", { id: "custom-map-container" }, [mapWrapper]);
}

/**
 * Creates the legend UI with filter buttons for marker types.
 *
 * @param {Object} typeLabels - Mapping of marker types to labels.
 * @returns {HTMLElement} - The legend element.
 */
function createLegend(typeLabels = {}) {
  const legend = createElement("div", { id: "legend", class: "hidden" });
  Object.keys(typeLabels).forEach((type) => {
    const btn = createElement("button", { "data-type": type }, [
      typeLabels[type] || type,
    ]);
    legend.appendChild(btn);
  });
  // Reset filter button.
  const resetBtn = createElement(
    "button",
    { style: "margin-top:10px" },
    ["ðŸ”„ Show All"]
  );
  legend.appendChild(resetBtn);
  return legend;
}

/**
 * Creates the zoom control UI.
 *
 * @returns {HTMLElement} - The zoom control element.
 */
function createZoomControls() {
  const zoomInBtn = createElement("button", {}, ["+"]);
  const zoomOutBtn = createElement("button", {}, ["âˆ’"]);
  const zoomControls = createElement("div", { id: "zoom-controls" }, [
    zoomInBtn,
    zoomOutBtn,
  ]);
  return zoomControls;
}

/**
 * Creates the minimap UI that shows a static version of the map.
 *
 * @param {string} mapImageUrl - URL for the minimap image.
 * @returns {HTMLElement} - The minimap element.
 */
function createMinimap(mapImageUrl) {
  const minimapImage = createElement("img", { src: mapImageUrl });
  const minimapViewport = createElement("div", { id: "minimap-viewport" });
  return createElement("div", { id: "minimap" }, [minimapImage, minimapViewport]);
}

/**
 * Creates the info panel UI for displaying marker details.
 *
 * @returns {HTMLElement} - The info panel element.
 */
function createInfoPanel() {
  const infoTitle = createElement("h2", { id: "info-title" }, ["Info"]);
  const infoContent = createElement("p", { id: "info-content" }, [
    "Details will go here",
  ]);
  const closeBtn = createElement("button", { id: "close-info-panel" }, [
    "Close",
  ]);
  const panel = createElement("div", { id: "marker-info-panel" }, [
    closeBtn,
    infoTitle,
    infoContent,
  ]);
  // Close button hides the info panel.
  closeBtn.addEventListener("click", () => panel.classList.remove("active"));
  return panel;
}

/**
 * Creates marker elements from backend data.
 *
 * @param {Array} markers - Array of marker objects.
 * @param {Object} spritePositions - Mapping of marker types to background positions.
 * @returns {HTMLElement[]} - Array of marker elements.
 */
function createMarkers(markers = [], spritePositions = {}) {
  const markerElements = markers.map((marker) => {
    const label = createElement("div", { class: "marker-label" }, [
      marker.name,
    ]);
    const el = createElement(
      "div",
      {
        class: "marker",
        id: marker.id,
        title: marker.name,
        "data-type": marker.type,
        style: `
          left:${marker.x}px;
          top:${marker.y}px;
          background-position:${spritePositions[marker.type] || "0px 0px"};
        `,
      },
      [label]
    );
    return el;
  });
  return markerElements;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   MAP INTERACTIONS & UPDATES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/**
 * Initializes panning and zooming interactions. Returns an object with helper methods.
 *
 * @param {HTMLElement} mapContainer - The container holding the map.
 * @param {HTMLElement} zoomControls - The container holding zoom in/out buttons.
 * @param {HTMLElement} minimap - The minimap container.
 * @returns {Object} - An object with an applyZoom() function.
 */
function initMapInteractions(mapContainer, zoomControls, minimap) {
  // Retrieve the inner wrapper and image.
  const mapWrapper = mapContainer.querySelector("#map-wrapper");
  const mapInner = mapContainer.querySelector("#map-inner");
  const [zoomInBtn, zoomOutBtn] = zoomControls.querySelectorAll("button");

  // Variables for panning and zooming.
  let isDragging = false;
  let startX = 0;
  let startY = 0;
  let mapX = 0;
  let mapY = 0;
  let zoom = 1;
  const zoomStep = 0.1;

  /**
   * Applies the current pan/zoom transformation to the map and updates the minimap.
   */
  function applyZoom() {
    mapWrapper.style.transform = `translate(${mapX}px, ${mapY}px) scale(${zoom})`;
    updateMinimapViewport();
  }

  /**
   * Updates the minimap viewport rectangle based on current pan/zoom.
   */
  function updateMinimapViewport() {
    const minimapViewport = minimap.querySelector("#minimap-viewport");
    // Use natural image width if available, else default.
    const mapImgWidth = mapInner.naturalWidth || 2000;
    const minimapScale = minimap.offsetWidth / mapImgWidth;
    const visibleWidth = mapContainer.offsetWidth / zoom;
    const visibleHeight = mapContainer.offsetHeight / zoom;
    minimapViewport.style.width = `${visibleWidth * minimapScale}px`;
    minimapViewport.style.height = `${visibleHeight * minimapScale}px`;
    minimapViewport.style.left = `${-mapX * minimapScale}px`;
    minimapViewport.style.top = `${-mapY * minimapScale}px`;
  }

  // Map panning event handlers.
  mapContainer.addEventListener("mousedown", (e) => {
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;
    mapContainer.style.cursor = "grabbing";
  });

  document.addEventListener("mousemove", (e) => {
    if (!isDragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    mapX += dx;
    mapY += dy;
    applyZoom();
    startX = e.clientX;
    startY = e.clientY;
  });

  document.addEventListener("mouseup", () => {
    isDragging = false;
    mapContainer.style.cursor = "grab";
  });

  // Zoom in/out buttons.
  zoomInBtn.addEventListener("click", () => {
    zoom += zoomStep;
    applyZoom();
  });
  zoomOutBtn.addEventListener("click", () => {
    zoom = Math.max(0.5, zoom - zoomStep);
    applyZoom();
  });

  // Clicking the minimap recenters the main map.
  minimap.addEventListener("click", (e) => {
    e.stopPropagation();
    const rect = minimap.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    const mapImgWidth = mapInner.naturalWidth || 2000;
    const minimapScale = minimap.offsetWidth / mapImgWidth;
    const targetX = clickX / minimapScale;
    const targetY = clickY / minimapScale;
    const containerCenterX = mapContainer.offsetWidth / 2;
    const containerCenterY = mapContainer.offsetHeight / 2;
    mapX = containerCenterX - targetX * zoom;
    mapY = containerCenterY - targetY * zoom;
    applyZoom();
  });

  // Expose the applyZoom function for use after changes.
  return { applyZoom };
}

/**
 * Attaches interactions to the legend for filtering markers.
 *
 * @param {HTMLElement} legend - The legend element.
 * @param {HTMLElement[]} markerElements - Array of marker elements.
 */
function attachLegendInteractions(legend, markerElements) {
  // Filter markers by type when clicking on legend buttons.
  legend.querySelectorAll("button[data-type]").forEach((btn) => {
    btn.addEventListener("click", () => {
      const type = btn.getAttribute("data-type");
      markerElements.forEach((el) => {
        el.style.display = el.dataset.type === type ? "block" : "none";
      });
    });
  });
  // Reset filtering.
  const resetBtn = legend.querySelector("button:not([data-type])");
  if (resetBtn) {
    resetBtn.addEventListener("click", () => {
      markerElements.forEach((el) => {
        el.style.display = "block";
      });
    });
  }
}

/**
 * Attaches click listeners to markers so that details load in the info panel.
 *
 * @param {HTMLElement[]} markerElements - Array of marker elements.
 * @param {boolean} isLoggedIn - Whether the user is logged in.
 * @param {HTMLElement} infoPanel - The info panel element.
 */
function attachMarkerClickListeners(markerElements, isLoggedIn, infoPanel) {
  const infoTitle = infoPanel.querySelector("#info-title");
  const infoContent = infoPanel.querySelector("#info-content");

  markerElements.forEach((el) => {
    el.addEventListener("click", async (e) => {
      e.stopPropagation();
      infoTitle.textContent = el.title;
      infoContent.textContent = "Loading...";
      try {
        // Load additional place details into the info panel.
        displayPlace(isLoggedIn, el.id, infoContent);
      } catch (error) {
        console.error("Error loading place details:", error);
        infoContent.textContent = "Error loading details.";
      }
      infoPanel.classList.add("active");
    });
  });
}
